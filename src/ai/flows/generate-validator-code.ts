
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Generates C++ code to validate inputs for a given problem statement.
 *
 * - generateValidatorCode - A function that generates C++ validator code.
 * - GenerateValidatorCodeInput - The input type for the generateValidatorCode function.
 * - GenerateValidatorCodeOutput - The return type for the generateValidatorCode function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const GenerateValidatorCodeInputSchema = z.object({
  problemStatement: z
    .string()
    .describe('The problem statement including input format details.'),
});

export type GenerateValidatorCodeInput = z.infer<typeof GenerateValidatorCodeInputSchema>;

const GenerateValidatorCodeOutputSchema = z.object({
  validatorCode: z
    .string()
    .describe('The generated C++ code to validate the input.'),
});

export type GenerateValidatorCodeOutput = z.infer<typeof GenerateValidatorCodeOutputSchema>;

export async function generateValidatorCode(
  input: GenerateValidatorCodeInput
): Promise<GenerateValidatorCodeOutput> {
  return generateValidatorCodeFlow(input);
}

const generateValidatorCodePrompt = ai.definePrompt({
  name: 'generateValidatorCodePrompt',
  input: {schema: GenerateValidatorCodeInputSchema},
  output: {schema: GenerateValidatorCodeOutputSchema},
  prompt: `You are a C++ expert tasked with generating validator code for competitive programming problems using testlib.h.

  Based on the following problem statement, generate C++ code that validates the input.
  The validator must ensure the input strictly adheres to all format and constraint details specified in the problem statement.
  It is crucial to use 'testlib.h' utilities for robust validation.
  - For reading inputs, use methods like \`inf.readInt()\`, \`inf.readSpace()\`, \`inf.readEoln()\`, etc.
  - For checks, you MUST use \`inf.ensuref(condition, "format string with placeholders for values like %d, %s, etc.", corresponding_variables...)\` to assert conditions. This function provides descriptive error messages when a condition fails.
  - If a validation fails and you need to exit immediately with a very specific message that might not fit \`ensuref\` well, you can use \`quitf(_wa, "Error message: %s was %d", variableName, variableValue);\` or similar \`quitf\` variants from testlib.h.
  The validator code should read from standard input (via the \`inf\` object from testlib.h).
  It must call \`registerValidation(argc, argv);\` at the beginning of main.
  If the input is valid according to all problem constraints, it must eventually call \`inf.readEof();\` and then typically return 0 (e.g., by main function ending).

  Problem Statement:
  {{{problemStatement}}}

  Ensure the generated code is efficient, correct, and adheres to best practices for competitive programming validators using testlib.h.
  Include necessary headers, primarily \`#include "testlib.h"\`.
  Focus on providing clear, specific error messages for each validation check using \`inf.ensuref\` or \`quitf\` from testlib.h.
  `,
});

const generateValidatorCodeFlow = ai.defineFlow(
  {
    name: 'generateValidatorCodeFlow',
    inputSchema: GenerateValidatorCodeInputSchema,
    outputSchema: GenerateValidatorCodeOutputSchema,
  },
  async input => {
    const {output} = await generateValidatorCodePrompt(input);
    return output!;
  }
);

