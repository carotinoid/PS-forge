
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Generates C++ code to validate inputs for a given problem statement.
 *
 * - generateValidatorCode - A function that generates C++ validator code.
 * - GenerateValidatorCodeInput - The input type for the generateValidatorCode function.
 * - GenerateValidatorCodeOutput - The return type for the generateValidatorCode function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const GenerateValidatorCodeInputSchema = z.object({
  problemStatement: z
    .string()
    .describe('The problem statement including input format details.'),
});

export type GenerateValidatorCodeInput = z.infer<typeof GenerateValidatorCodeInputSchema>;

const GenerateValidatorCodeOutputSchema = z.object({
  validatorCode: z
    .string()
    .describe('The generated C++ code to validate the input.'),
});

export type GenerateValidatorCodeOutput = z.infer<typeof GenerateValidatorCodeOutputSchema>;

export async function generateValidatorCode(
  input: GenerateValidatorCodeInput
): Promise<GenerateValidatorCodeOutput> {
  return generateValidatorCodeFlow(input);
}

const generateValidatorCodePrompt = ai.definePrompt({
  name: 'generateValidatorCodePrompt',
  input: {schema: GenerateValidatorCodeInputSchema},
  output: {schema: GenerateValidatorCodeOutputSchema},
  prompt: `You are a C++ expert tasked with generating validator code for competitive programming problems using testlib.h.

  Based on the following problem statement, generate C++ code that validates the input.
  The validator must ensure the input strictly adheres to all format and constraint details specified in the problem statement.
  It is crucial to use 'testlib.h' utilities for robust validation.
  - For reading inputs, use methods like \`inf.readInt()\`, \`inf.readSpace()\`, \`inf.readEoln()\`, etc.
  - For checks, you can use \`inf.ensure(condition, "format string...", args...)\` to assert conditions with custom formatted messages.
  - If a validation fails, the program must exit with a non-zero code. This is typically done by calling an appropriate \`quitf(_wa, "Error message about specific validation failure: %s was %d", variableName, variableValue);\` function from testlib.h. This provides the most descriptive error.
  The validator code should read from standard input (via the \`inf\` object from testlib.h).
  It must call \`registerValidation(argc, argv);\` at the beginning of main.
  If the input is valid according to all problem constraints, it must eventually call \`inf.readEof();\` and then typically return 0 (e.g., by main function ending).

  Problem Statement:
  {{{problemStatement}}}

  Ensure the generated code is efficient, correct, and adheres to best practices for competitive programming validators using testlib.h.
  Include necessary headers, primarily \`#include "testlib.h"\`.
  Focus on providing clear, specific error messages for each validation check, ideally using \`quitf\` or the formatted version of \`inf.ensure\`.
  `,
});

const generateValidatorCodeFlow = ai.defineFlow(
  {
    name: 'generateValidatorCodeFlow',
    inputSchema: GenerateValidatorCodeInputSchema,
    outputSchema: GenerateValidatorCodeOutputSchema,
  },
  async input => {
    const {output} = await generateValidatorCodePrompt(input);
    return output!;
  }
);

